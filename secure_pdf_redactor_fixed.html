<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VOKRA — Secure PDF Redactor (Client-Only)</title>
    <style>
      /* Theme tokens: Dark (default) */
      :root {
        --bg-gradient: linear-gradient(120deg, #0b1020, #0d1631);
        --header-gradient: linear-gradient(120deg, #0c1326, #0e1a3a);
        --panel: #151c33;
        --panel-2: #0e1530;
        --border: rgba(255, 255, 255, 0.08);
        --accent: #8b9dff;
        --text: #e9ecff;
        --muted: #a9b1d6;
        --danger: #ff5c7a;
        --success: #5ed48b;
        --ring: rgba(139, 157, 255, 0.35);
        --chip: #0e1536;
        --chip-border: var(--border);
        --progress-bg: #101736;
        --handle: #101736;
        --handle-border: rgba(255, 255, 255, 0.9);
        --testlog-bg: #0e1536;
        --testlog-text: #d0d6ff;
      }
      /* Light theme overrides */
      :root[data-theme="light"] {
        --bg-gradient: linear-gradient(120deg, #f6f8ff, #eef3ff);
        --header-gradient: linear-gradient(120deg, #f5f7ff, #eaf0ff);
        --panel: #ffffff;
        --panel-2: #f5f7ff;
        --border: rgba(0, 0, 0, 0.08);
        --accent: #3f5cff;
        --text: #0f172a;
        --muted: #64748b;
        --danger: #e11d48;
        --success: #16a34a;
        --ring: rgba(63, 92, 255, 0.25);
        --chip: #eef3ff;
        --chip-border: var(--border);
        --progress-bg: #e5e9ff;
        --handle: #0f172a;
        --handle-border: rgba(255, 255, 255, 0.95);
        --testlog-bg: #eef3ff;
        --testlog-text: #0f172a;
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica,
          Arial;
        color: var(--text);
        background: var(--bg-gradient);
      }
      header {
        position: sticky;
        top: 0;
        z-index: 50;
        background: var(--header-gradient);
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.25);
      }
      .wrap {
        max-width: 1200px;
        margin: 0 auto;
        padding: 12px 18px;
      }
      h1 {
        font-size: 18px;
        margin: 0;
        letter-spacing: 0.2px;
      }

      /* App layout */
      .app {
        max-width: 1200px;
        margin: 12px auto;
        padding: 0 18px;
        display: grid;
        grid-template-columns: 260px 1fr;
        gap: 16px;
      }
      .sidebar {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
        display: flex;
        flex-direction: column;
        gap: 12px;
        min-height: 70vh;
      }
      .editor {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12);
        min-height: 70vh;
        position: relative;
      }

      .section-title {
        font-weight: 700;
        font-size: 13px;
        letter-spacing: 0.2px;
        color: #cbd3ff;
        opacity: 0.95;
      }
      :root[data-theme="light"] .section-title {
        color: #30418f;
        opacity: 1;
      }
      .hint {
        color: var(--muted);
      }

      /* Upload / drop */
      .drop {
        border: 1px dashed var(--border);
        border-radius: 12px;
        padding: 16px;
        text-align: center;
        background: var(--panel-2);
      }
      .drop.drag {
        outline: 2px solid var(--accent);
        box-shadow: 0 0 0 6px var(--ring);
      }
      input[type="file"] {
        display: none;
      }
      .btn {
        appearance: none;
        border: none;
        border-radius: 10px;
        padding: 10px 12px;
        color: var(--text);
        background: #1f2750;
        cursor: pointer;
        transition: 0.15s ease;
        box-shadow: 0 0 0 0 var(--ring);
      }
      .btn:hover {
        transform: translateY(-1px);
      }
      .btn:active {
        transform: translateY(0);
      }
      .btn.primary {
        background: linear-gradient(135deg, #3a49a6, #5f73ff);
      }
      .btn.ghost {
        background: transparent;
        border: 1px solid var(--border);
      }
      .btn.block {
        display: block;
        width: 100%;
      }
      :root[data-theme="light"] .btn {
        background: #eef1ff;
      }
      :root[data-theme="light"] .btn.primary {
        background: linear-gradient(135deg, #5b6cff, #7d8cff);
        color: white;
      }

      /* Tools */
      .tools {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .kbd {
        font-family: ui-monospace, Menlo, Consolas, monospace;
        font-size: 12px;
        padding: 0.05em 0.35em;
        border-radius: 6px;
        background: var(--chip);
        border: 1px solid var(--chip-border);
      }

      /* Thumbnails */
      .thumbs {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        overflow: auto;
      }
      .thumb {
        position: relative;
        border: 1px solid var(--border);
        background: var(--panel-2);
        border-radius: 8px;
        padding: 6px;
        cursor: pointer;
      }
      .thumb canvas {
        display: block;
        width: 100%;
        height: auto;
        border-radius: 4px;
      }
      .thumb .badge {
        position: absolute;
        top: 6px;
        left: 6px;
        font-size: 11px;
        padding: 0.15em 0.45em;
        background: #0008;
        border: 1px solid var(--border);
        border-radius: 6px;
        color: white;
      }
      :root[data-theme="light"] .thumb .badge {
        background: #0007;
      }
      .thumb.active {
        outline: 2px solid var(--accent);
        box-shadow: 0 0 0 6px var(--ring);
      }

      /* Editor viewer */
      .editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        background: var(--panel-2);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 8px 10px;
        margin-bottom: 10px;
      }
      .viewer {
        height: calc(70vh - 56px);
        overflow: auto;
        border-radius: 10px;
        background: linear-gradient(180deg, #0f1639, #0b1233);
        padding: 12px;
      }
      :root[data-theme="light"] .viewer {
        background: linear-gradient(180deg, #f0f3ff, #e8ecff);
      }
      .page {
        position: relative;
        margin: 0 auto 16px;
        width: fit-content;
      }
      canvas.pdfCanvas {
        display: block;
        border-radius: 8px;
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.15);
      }
      .overlay {
        position: absolute;
        inset: 0;
        user-select: none;
      }
      .redaction {
        position: absolute;
        background: rgba(255, 255, 255, 0.52);
        border: 1px solid rgba(255, 255, 255, 0.9);
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.06);
        border-radius: 4px;
        cursor: move;
      }
      .redaction.selected {
        outline: 2px solid var(--accent);
      }
      .redaction .handle {
        position: absolute;
        width: 10px;
        height: 10px;
        background: var(--handle);
        border: 1px solid var(--handle-border);
        border-radius: 2px;
        box-shadow: 0 0 0 1px #0006;
      }
      .handle.nw {
        left: -5px;
        top: -5px;
        cursor: nwse-resize;
      }
      .handle.ne {
        right: -5px;
        top: -5px;
        cursor: nesw-resize;
      }
      .handle.sw {
        left: -5px;
        bottom: -5px;
        cursor: nesw-resize;
      }
      .handle.se {
        right: -5px;
        bottom: -5px;
        cursor: nwse-resize;
      }

      /* Redaction numbering label & list */
      .redaction .tag {
        position: absolute;
        right: 2px;
        top: 2px;
        font-size: 10px;
        line-height: 1;
        padding: 0.1em 0.35em;
        border-radius: 6px;
        background: #1f2750;
        color: #fff;
        border: 1px solid var(--border);
      }
      :root[data-theme="light"] .redaction .tag {
        background: #3f5cff;
        color: #fff;
      }
      .redaction-list {
        background: var(--panel-2);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px;
        max-height: 180px;
        overflow: auto;
      }
      .redaction-list .item {
        cursor: pointer;
        margin: 4px 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 6px;
        padding: 4px 6px;
        border-radius: 6px;
      }
      .redaction-list .item:hover {
        background: var(--chip);
      }
      .redaction-list .item.active {
        outline: 2px solid var(--accent);
        box-shadow: 0 0 0 4px var(--ring);
      }
      .redaction-list .item .label {
        flex: 1;
      }
      .redaction-list .item .del {
        appearance: none;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--danger);
        border-radius: 6px;
        padding: 2px 6px;
        font-size: 12px;
        cursor: pointer;
      }

      .progress {
        height: 8px;
        width: 180px;
        background: var(--progress-bg);
        border-radius: 999px;
        overflow: hidden;
        border: 1px solid var(--border);
      }
      .progress > i {
        display: block;
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, #5f73ff, #8b9dff);
      }

      /* Empty state & loading */
      .empty {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        color: var(--muted);
      }
      .loading {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: #0006;
        border-radius: 12px;
      }
      .loading.show {
        display: flex;
      }

      /* Error/diagnostic log style */
      .testlog {
        white-space: pre-wrap;
        font-family: ui-monospace, Menlo, Consolas, monospace;
        font-size: 12px;
        line-height: 1.55;
        background: var(--testlog-bg);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        color: var(--testlog-text);
      }

      @media (max-width: 980px) {
        .app {
          grid-template-columns: 1fr;
        }
        .viewer {
          height: 60vh;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div
        class="wrap"
        style="
          display: flex;
          gap: 12px;
          align-items: center;
          justify-content: space-between;
        ">
        <h1>VOKRA — Secure PDF Redactor (Client-Only)</h1>
        <div style="display: flex; gap: 8px; align-items: center">
          <button
            id="themeToggle"
            class="btn ghost"
            title="Toggle light/dark theme">
            🌙 Dark
          </button>
          <button
            id="exportBtn"
            class="btn primary"
            title="Export as image-only, safe PDF">
            ⬇️ Export Safe PDF
          </button>
          <div id="exportProgress" class="progress" aria-hidden="true">
            <i></i>
          </div>
        </div>
      </div>
    </header>

    <div class="app" id="app">
      <!-- Sidebar -->
      <aside class="sidebar">
        <div class="section">
          <div class="section-title">1) Upload / Drag & Drop</div>
          <div id="drop" class="drop">
            <div style="margin-bottom: 8px">Drop a PDF here, or</div>
            <label class="btn block" for="pdfFile">📄 Choose PDF</label>
            <input id="pdfFile" type="file" accept=".pdf,application/pdf" />
            <div class="hint" style="margin-top: 8px">
              Fully local, processed in your browser only.
            </div>
          </div>
        </div>

        <div class="section">
          <div class="section-title">2) Tools</div>
          <div class="tools">
            <button
              id="drawBtn"
              class="btn"
              aria-pressed="false"
              title="Draw rectangle (R)">
              ▭ Draw Rect
            </button>
            <button
              id="clearAllBtn"
              class="btn ghost"
              title="Clear all redactions">
              🗑️ Clear All
            </button>
            <div
              class="btn ghost"
              style="
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 6px;
              ">
              Zoom
              <input
                id="zoom"
                type="range"
                min="60"
                max="200"
                step="5"
                value="110"
                style="width: 120px" />
              <span id="zoomVal">110%</span>
            </div>
          </div>
          <div class="hint" style="margin-top: 6px">
            Shortcuts: <span class="kbd">R</span> toggle draw,
            <span class="kbd">Delete</span> remove selection, double-click
            rectangle to remove.
          </div>
        </div>

        <div class="section">
          <div class="section-title">3) Redactions</div>
          <div id="redactionList" class="redaction-list hint">
            No redactions yet
          </div>
        </div>

        <div class="section">
          <div class="section-title">4) Page Thumbnails</div>
          <div id="thumbs" class="thumbs" aria-live="polite"></div>
        </div>

        <div class="section">
          <div class="section-title">Status</div>
          <div id="fileInfo" class="hint">No file selected</div>
        </div>
      </aside>

      <!-- Editor -->
      <section class="editor">
        <div class="editor-header">
          <div id="pageStatus" class="hint">Idle</div>
          <div style="display: flex; gap: 10px; align-items: center">
            <span class="hint"
              >Export will burn rectangles into pixels (irreversible).</span
            >
          </div>
        </div>
        <div id="viewer" class="viewer">
          <div id="empty" class="empty">
            <div>
              <div style="font-size: 22px; margin-bottom: 6px">
                Upload a PDF on the left to start
              </div>
              <div class="hint">
                Drag & drop into the left panel or click “Choose PDF”.
              </div>
            </div>
          </div>
        </div>
        <div id="loading" class="loading">
          <div class="btn">Rendering…</div>
        </div>
      </section>
    </div>

    <main class="wrap"></main>

    <!-- ===== Robust loader: ensure libraries are defined BEFORE use ===== -->
    <script>
      (function () {
        // ---- Theme bootstrapping ----
        const THEME_KEY = "vokraTheme";
        const prefersLight =
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: light)").matches;
        function applyTheme(t) {
          document.documentElement.setAttribute("data-theme", t);
          localStorage.setItem(THEME_KEY, t);
          const btn = document.getElementById("themeToggle");
          if (btn) {
            btn.textContent = t === "light" ? "☀️ Light" : "🌙 Dark";
            btn.setAttribute("aria-pressed", t === "dark");
            btn.title = "Toggle light/dark theme";
          }
        }
        const saved = localStorage.getItem(THEME_KEY);
        applyTheme(saved || (prefersLight ? "light" : "dark"));

        // Global error surfacing
        function surfaceError(msg) {
          const box = document.createElement("div");
          box.className = "testlog";
          box.style.borderColor = "rgba(255,92,122,.6)";
          box.textContent = "[Error] " + msg;
          (document.querySelector("main") || document.body).prepend(box);
        }
        window.addEventListener("error", (e) =>
          surfaceError(e.message || String(e))
        );
        window.addEventListener("unhandledrejection", (e) =>
          surfaceError(e.reason?.message || String(e.reason || e))
        );

        async function loadScript(src) {
          return new Promise((res, rej) => {
            const s = document.createElement("script");
            s.src = src;
            s.async = false;
            s.crossOrigin = "anonymous";
            s.referrerPolicy = "no-referrer";
            s.onload = () => res(src);
            s.onerror = () => rej(new Error("Failed to load " + src));
            document.head.appendChild(s);
          });
        }
        async function ensurePDFJS() {
          if (window.pdfjsLib) return { mode: "global", src: "preloaded" };
          const umdList = [
            "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.4.168/build/pdf.min.js",
            "https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.min.js",
            "https://mozilla.github.io/pdf.js/build/pdf.js",
            "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.js",
          ];
          for (const url of umdList) {
            try {
              await loadScript(url);
              if (window.pdfjsLib) {
                return { mode: "umd", src: url };
              }
            } catch (e) {}
          }
          const mjsList = [
            "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.4.168/build/pdf.mjs",
            "https://ga.jspm.io/npm:pdfjs-dist@4.4.168/build/pdf.mjs",
            "https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.mjs",
          ];
          for (const url of mjsList) {
            try {
              const mod = await import(url);
              window.pdfjsLib = { ...mod };
              return { mode: "esm", src: url };
            } catch (e) {}
          }
          throw new Error("Unable to load pdf.js (CDN blocked or offline)");
        }
        async function ensureJSPDF() {
          if (window.jspdf?.jsPDF) return { mode: "global", src: "preloaded" };
          const list = [
            "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js",
            "https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js",
            "https://ga.jspm.io/npm:jspdf@2.5.1/dist/jspdf.umd.min.js",
          ];
          for (const url of list) {
            try {
              await loadScript(url);
              if (window.jspdf?.jsPDF) return { mode: "umd", src: url };
            } catch (e) {}
          }
          throw new Error("Unable to load jsPDF (CDN blocked or offline)");
        }

        (async function boot() {
          try {
            const pdfInfo = await ensurePDFJS();
            window.__PDF_DISABLE_WORKER__ = true; // render in main thread to avoid worker CORS issues
            if (pdfInfo.src && pdfInfo.src.includes("pdf.min.js")) {
              const workerSrc = pdfInfo.src.replace(
                "pdf.min.js",
                "pdf.worker.min.js"
              );
              if (window.pdfjsLib?.GlobalWorkerOptions)
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;
            } else if (pdfInfo.src && pdfInfo.src.includes("pdf.mjs")) {
              const workerSrc = pdfInfo.src.replace(
                "pdf.mjs",
                "pdf.worker.mjs"
              );
              if (window.pdfjsLib?.GlobalWorkerOptions)
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;
            }
            const jsPDFInfo = await ensureJSPDF();
            initApp(window.pdfjsLib, window.jspdf);
            const diag = document.createElement("div");
            diag.className = "testlog";
            diag.textContent = `Loaded pdf.js: ${pdfInfo.mode} @ ${pdfInfo.src}\nLoaded jsPDF: ${jsPDFInfo.mode} @ ${jsPDFInfo.src}`;
            diag.style.borderColor = "rgba(94,212,139,.5)";
            document.querySelector("main").prepend(diag);
          } catch (e) {
            surfaceError(
              "Init failed: " +
                e.message +
                ".\nTip: if your network blocks CDNs, place pdfjs-dist & jsPDF next to this HTML and switch sources to local paths."
            );
          }
        })();

        // ===================== APP =====================
        function initApp(pdfjsLib, jspdfNS) {
          const $ = (sel, el = document) => el.querySelector(sel);
          const $$ = (sel, el = document) =>
            Array.from(el.querySelectorAll(sel));

          const drop = $("#drop");
          const fileInput = $("#pdfFile");
          const viewer = $("#viewer");
          const empty = $("#empty");
          const loading = $("#loading");
          const drawBtn = $("#drawBtn");
          const exportBtn = $("#exportBtn");
          const clearAllBtn = $("#clearAllBtn");
          const zoomRange = $("#zoom");
          const zoomVal = $("#zoomVal");
          const progressBar = $("#exportProgress");
          const progressFill = $("#exportProgress i");
          const thumbs = $("#thumbs");
          const fileInfo = $("#fileInfo");
          const pageStatus = $("#pageStatus");
          const themeToggle = $("#themeToggle");
          const redactList = $("#redactionList");

          let pdfDoc = null;
          let scale = parseInt(zoomRange.value, 10) / 100;
          let drawMode = false;
          const redactions = new Map(); // pageNum => rects
          let originalFileName = ""; // keep original file name
          let renderToken = 0; // bump to invalidate in-flight renders
          let zoomTimer = null; // debounce zoom re-render

          themeToggle.addEventListener("click", () => {
            const cur =
              document.documentElement.getAttribute("data-theme") === "light"
                ? "light"
                : "dark";
            const next = cur === "light" ? "dark" : "light";
            document.documentElement.setAttribute("data-theme", next);
            localStorage.setItem("vokraTheme", next);
            themeToggle.textContent = next === "light" ? "☀️ Light" : "🌙 Dark";
          });

          function toast(msg, type = "info") {
            let t = document.createElement("div");
            t.textContent = msg;
            t.style.position = "fixed";
            t.style.zIndex = 1000;
            t.style.right = "16px";
            t.style.bottom = "16px";
            t.style.background =
              type === "error"
                ? "#b91c1c"
                : type === "success"
                ? "#166534"
                : "#1f2750";
            t.style.color = "#fff";
            t.style.padding = "10px 12px";
            t.style.borderRadius = "10px";
            t.style.boxShadow = "0 8px 24px #0006";
            document.body.appendChild(t);
            setTimeout(() => {
              t.remove();
            }, 2200);
          }

          function setDrawMode(on) {
            drawMode = !!on;
            drawBtn.setAttribute("aria-pressed", on);
            drawBtn.textContent = on ? "✏️ Drawing… (R)" : "▭ Draw Rect";
          }
          function updateZoomDisplay() {
            zoomVal.textContent = Math.round(scale * 100) + "%";
          }

          // Ensure selecting the same file twice still fires 'change'
          fileInput.addEventListener("click", () => {
            fileInput.value = "";
          });

          // Drag & drop
          ["dragenter", "dragover"].forEach((t) =>
            drop.addEventListener(t, (e) => {
              e.preventDefault();
              drop.classList.add("drag");
            })
          );
          ["dragleave", "drop"].forEach((t) =>
            drop.addEventListener(t, (e) => {
              e.preventDefault();
              drop.classList.remove("drag");
            })
          );
          drop.addEventListener("drop", (e) => {
            const f = e.dataTransfer.files?.[0];
            if (f) loadPDF(f);
          });
          fileInput.addEventListener("change", (e) => {
            const f = e.target.files?.[0];
            if (f) loadPDF(f);
            else toast("No file selected", "error");
          });

          async function loadPDF(file) {
            try {
              loading.classList.add("show");
              fileInfo.textContent = `Loading: ${file.name}`;
              originalFileName = file.name; // remember original name
              empty?.remove();
              viewer.innerHTML = "";
              thumbs.innerHTML = "";
              redactions.clear();
              const buf = await file.arrayBuffer();

              const loadingTask = pdfjsLib.getDocument({
                data: buf,
                disableWorker: true,
              });
              loadingTask.onProgress = (p) => {
                const ratio =
                  p.loaded && p.total ? (p.loaded / p.total) * 100 : 0;
                pageStatus.textContent = `Loading… ${ratio.toFixed(0)}%`;
              };
              if (pdfjsLib.PasswordResponses) {
                loadingTask.onPassword = (updatePassword, reason) => {
                  const pwd = prompt(
                    reason === pdfjsLib.PasswordResponses.NEED_PASSWORD
                      ? "This PDF is encrypted. Enter password:"
                      : "Wrong password. Try again:"
                  );
                  if (pwd === null) {
                    throw new Error("Password input cancelled");
                  }
                  updatePassword(pwd);
                };
              }

              pdfDoc = await loadingTask.promise;
              fileInfo.textContent = `${file.name} • ${pdfDoc.numPages} pages`;
              await renderAllPages();
              await renderThumbs();
              setDrawMode(false); // default to idle after load
              pageStatus.textContent = `Page 1 / ${pdfDoc.numPages}`;
              viewer.scrollTo({ top: 0 });
              renumberAndList();
              toast("PDF loaded", "success");
            } catch (err) {
              console.error(err);
              alert("Failed to read PDF: " + err.message);
              const errBox = document.createElement("div");
              errBox.className = "testlog";
              errBox.textContent = "Load failed: " + err.message;
              viewer.innerHTML = "";
              viewer.appendChild(errBox);
              fileInfo.textContent = "Load failed";
            } finally {
              loading.classList.remove("show");
            }
          }

          zoomRange.addEventListener("input", () => {
            scale = parseInt(zoomRange.value, 10) / 100;
            updateZoomDisplay();
            if (!pdfDoc) return;
            if (zoomTimer) clearTimeout(zoomTimer);
            zoomTimer = setTimeout(async () => {
              await renderAllPages();
              renumberAndList();
            }, 150);
          });
          drawBtn.addEventListener("click", () => setDrawMode(!drawMode));
          document.addEventListener("keydown", (e) => {
            if (e.key.toLowerCase() === "r") setDrawMode(!drawMode);
            if (e.key === "Delete" || e.key === "Backspace") {
              const sel = $(".redaction.selected");
              if (sel) {
                const pageEl = sel.closest(".page");
                sel.remove();
                persistPageRects(pageEl);
              }
            }
          });
          clearAllBtn.addEventListener("click", () => {
            $$(".redaction").forEach((el) => el.remove());
            redactions.clear();
            renumberAndList();
          });

          // Render main pages
          async function renderAllPages() {
            const token = ++renderToken; // invalidate any in-flight renders
            viewer.innerHTML = "";
            for (let p = 1; p <= pdfDoc.numPages; p++) {
              // If a newer render started, stop immediately
              if (token !== renderToken) return;
              try {
                const page = await pdfDoc.getPage(p);
                const viewport = page.getViewport({ scale });
                const pageWrap = document.createElement("div");
                pageWrap.className = "page";
                pageWrap.dataset.page = p;
                pageWrap.tabIndex = 0;
                const canvas = document.createElement("canvas");
                canvas.className = "pdfCanvas";
                canvas.width = Math.ceil(viewport.width);
                canvas.height = Math.ceil(viewport.height);
                pageWrap.style.width = canvas.width + "px";
                const overlay = document.createElement("div");
                overlay.className = "overlay";
                overlay.style.width = canvas.width + "px";
                overlay.style.height = canvas.height + "px";
                pageWrap.appendChild(canvas);
                pageWrap.appendChild(overlay);

                // Render off-DOM first
                await page.render({
                  canvasContext: canvas.getContext("2d"),
                  viewport,
                }).promise;

                // Before appending, verify we're still the latest render
                if (token !== renderToken) return;
                viewer.appendChild(pageWrap);

                const saved = redactions.get(p) || [];
                saved.forEach((r) =>
                  overlay.appendChild(createRectEl(overlay, r))
                );

                pageWrap.addEventListener("focusin", () => {
                  $$(".page").forEach((el) => el.classList.remove("focused"));
                  pageWrap.classList.add("focused");
                  pageStatus.textContent = `Page ${p} / ${pdfDoc.numPages}`;
                  setActiveThumb(p);
                });

                // Drawing on overlay
                let start = null;
                overlay.addEventListener("pointerdown", (evt) => {
                  if (!drawMode) return;
                  overlay.setPointerCapture(evt.pointerId);
                  start = clientToLocal(evt, overlay);
                  const rect = createRectEl(overlay, {
                    x: start.x / overlay.clientWidth,
                    y: start.y / overlay.clientHeight,
                    w: 0,
                    h: 0,
                  });
                  overlay.appendChild(rect);
                  rect.classList.add("selected");
                });
                overlay.addEventListener("pointermove", (evt) => {
                  if (!drawMode || !start) return;
                  const cur = clientToLocal(evt, overlay);
                  const x = Math.min(start.x, cur.x),
                    y = Math.min(start.y, cur.y);
                  const w = Math.abs(cur.x - start.x),
                    h = Math.abs(cur.y - start.y);
                  const rect = overlay.querySelector(
                    ".redaction.selected:last-child"
                  );
                  if (rect) {
                    rect.style.left = x + "px";
                    rect.style.top = y + "px";
                    rect.style.width = w + "px";
                    rect.style.height = h + "px";
                    persistRect(rect);
                  }
                });
                overlay.addEventListener("pointerup", (evt) => {
                  if (!drawMode) return;
                  overlay.releasePointerCapture(evt.pointerId);
                  start = null;
                  persistPageRects(pageWrap);
                });
              } catch (err) {
                console.error("Render page " + p + " failed:", err);
                const fail = document.createElement("div");
                fail.className = "testlog";
                fail.textContent = `Page ${p} render failed: ${err.message}`;
                viewer.appendChild(fail);
              }
            }
          }

          // Thumbnails
          async function renderThumbs() {
            thumbs.innerHTML = "";
            for (let p = 1; p <= pdfDoc.numPages; p++) {
              try {
                const page = await pdfDoc.getPage(p);
                const viewport = page.getViewport({ scale: 0.18 });
                const c = document.createElement("canvas");
                c.width = Math.ceil(viewport.width);
                c.height = Math.ceil(viewport.height);
                await page.render({
                  canvasContext: c.getContext("2d"),
                  viewport,
                }).promise;
                const holder = document.createElement("div");
                holder.className = "thumb";
                holder.appendChild(c);
                const badge = document.createElement("div");
                badge.className = "badge";
                badge.textContent = p;
                holder.appendChild(badge);
                holder.addEventListener("click", () => {
                  const target = $(`.page[data-page="${p}"]`);
                  if (target) {
                    target.scrollIntoView({
                      behavior: "smooth",
                      block: "start",
                    });
                    target.focus();
                  }
                });
                thumbs.appendChild(holder);
              } catch (err) {
                const fail = document.createElement("div");
                fail.className = "thumb";
                fail.textContent = "Thumb failed for page " + p;
                thumbs.appendChild(fail);
              }
            }
            setActiveThumb(1);
          }
          function setActiveThumb(p) {
            $$(".thumb", thumbs).forEach((el, i) => {
              el.classList.toggle("active", i + 1 === p);
            });
          }

          function clientToLocal(evt, el) {
            const r = el.getBoundingClientRect();
            const x = Math.max(
              0,
              Math.min(evt.clientX - r.left, el.clientWidth)
            );
            const y = Math.max(
              0,
              Math.min(evt.clientY - r.top, el.clientHeight)
            );
            return { x, y };
          }
          function createRectEl(overlay, norm) {
            const rect = document.createElement("div");
            rect.className = "redaction";
            positionFromNorm(rect, overlay, norm);
            ["nw", "ne", "sw", "se"].forEach((pos) => {
              const h = document.createElement("i");
              h.className = "handle " + pos;
              rect.appendChild(h);
            });
            // number tag
            const lbl = document.createElement("b");
            lbl.className = "tag";
            lbl.textContent = "?";
            rect.appendChild(lbl);

            // Drag move
            rect.addEventListener("pointerdown", (e) => {
              if (e.target.classList.contains("handle")) return;
              selectRect(rect);
              const start = clientToLocal(e, overlay);
              const init = { left: rect.offsetLeft, top: rect.offsetTop };
              overlay.setPointerCapture(e.pointerId);
              function move(ev) {
                const cur = clientToLocal(ev, overlay);
                const dx = cur.x - start.x,
                  dy = cur.y - start.y;
                rect.style.left =
                  clamp(
                    init.left + dx,
                    0,
                    overlay.clientWidth - rect.offsetWidth
                  ) + "px";
                rect.style.top =
                  clamp(
                    init.top + dy,
                    0,
                    overlay.clientHeight - rect.offsetHeight
                  ) + "px";
                persistRect(rect);
              }
              function up() {
                overlay.releasePointerCapture(e.pointerId);
                overlay.removeEventListener("pointermove", move);
                overlay.removeEventListener("pointerup", up);
                persistPageRects(overlay.closest(".page"));
              }
              overlay.addEventListener("pointermove", move);
              overlay.addEventListener("pointerup", up, { once: true });
            });

            // Resize handles
            $$(".handle", rect).forEach((handle) => {
              handle.addEventListener("pointerdown", (e) => {
                e.stopPropagation();
                selectRect(rect);
                const start = clientToLocal(e, overlay);
                const init = {
                  left: rect.offsetLeft,
                  top: rect.offsetTop,
                  w: rect.offsetWidth,
                  h: rect.offsetHeight,
                };
                overlay.setPointerCapture(e.pointerId);
                function move(ev) {
                  const cur = clientToLocal(ev, overlay);
                  let left = init.left,
                    top = init.top,
                    w = init.w,
                    h = init.h;
                  const dx = cur.x - start.x,
                    dy = cur.y - start.y;
                  const cls = e.target.classList;
                  if (cls.contains("se")) {
                    w = init.w + dx;
                    h = init.h + dy;
                  }
                  if (cls.contains("sw")) {
                    w = init.w - dx;
                    left = init.left + dx;
                    h = init.h + dy;
                  }
                  if (cls.contains("ne")) {
                    w = init.w + dx;
                    h = init.h - dy;
                    top = init.top + dy;
                  }
                  if (cls.contains("nw")) {
                    w = init.w - dx;
                    left = init.left + dx;
                    h = init.h - dy;
                    top = init.top + dy;
                  }
                  w = Math.max(6, Math.min(w, overlay.clientWidth - left));
                  h = Math.max(6, Math.min(h, overlay.clientHeight - top));
                  left = clamp(left, 0, overlay.clientWidth - w);
                  top = clamp(top, 0, overlay.clientHeight - h);
                  rect.style.left = left + "px";
                  rect.style.top = top + "px";
                  rect.style.width = w + "px";
                  rect.style.height = h + "px";
                  persistRect(rect);
                }
                function up() {
                  overlay.releasePointerCapture(e.pointerId);
                  overlay.removeEventListener("pointermove", move);
                  overlay.removeEventListener("pointerup", up);
                  persistPageRects(overlay.closest(".page"));
                }
                overlay.addEventListener("pointermove", move);
                overlay.addEventListener("pointerup", up);
              });
            });

            rect.addEventListener("dblclick", () => {
              const pageEl = overlay.closest(".page");
              rect.remove();
              persistPageRects(pageEl);
            });
            rect.addEventListener("pointerup", () => selectRect(rect));
            return rect;
          }

          function highlightListForRect(rect) {
            const num = rect?.dataset?.num;
            if (!num) return;
            $$(".redaction-list .item").forEach((li) => {
              li.classList.toggle("active", li.dataset.num === String(num));
            });
          }

          function selectRect(rect) {
            $$(".redaction").forEach((r) => r.classList.remove("selected"));
            rect.classList.add("selected");
            rect.scrollIntoView({ block: "nearest" });
            highlightListForRect(rect);
          }
          function clamp(v, min, max) {
            return Math.max(min, Math.min(max, v));
          }
          function positionFromNorm(rect, overlay, norm) {
            rect.style.left = norm.x * overlay.clientWidth + "px";
            rect.style.top = norm.y * overlay.clientHeight + "px";
            rect.style.width = norm.w * overlay.clientWidth + "px";
            rect.style.height = norm.h * overlay.clientHeight + "px";
            rect.dataset.x = norm.x;
            rect.dataset.y = norm.y;
            rect.dataset.w = norm.w;
            rect.dataset.h = norm.h;
          }
          function persistRect(rect) {
            const overlay = rect.parentElement;
            const n = {
              x: rect.offsetLeft / overlay.clientWidth,
              y: rect.offsetTop / overlay.clientHeight,
              w: rect.offsetWidth / overlay.clientWidth,
              h: rect.offsetHeight / overlay.clientHeight,
            };
            rect.dataset.x = n.x;
            rect.dataset.y = n.y;
            rect.dataset.w = n.w;
            rect.dataset.h = n.h;
          }
          function persistPageRects(pageEl) {
            const pageNum = parseInt(pageEl.dataset.page, 10);
            const overlay = $(".overlay", pageEl);
            const list = $$(".redaction", overlay).map((r) => ({
              x: +r.dataset.x,
              y: +r.dataset.y,
              w: +r.dataset.w,
              h: +r.dataset.h,
            }));
            if (list.length) redactions.set(pageNum, list);
            else redactions.delete(pageNum);
            renumberAndList();
          }

          function renumberAndList() {
            try {
              let n = 0;
              const items = [];
              const total = pdfDoc ? pdfDoc.numPages : 0;
              for (let p = 1; p <= total; p++) {
                const pageEl = document.querySelector(
                  `.page[data-page="${p}"]`
                );
                if (!pageEl) continue;
                const rects = $$(".redaction", pageEl);
                rects.forEach((r) => {
                  n++;
                  r.dataset.num = n;
                  const t = r.querySelector(".tag");
                  if (t) t.textContent = n;
                  items.push({ num: n, page: p, el: r });
                });
              }
              if (redactList) {
                redactList.innerHTML = "";
                if (items.length === 0) {
                  redactList.textContent = "No redactions yet";
                } else {
                  const ol = document.createElement("ol");
                  ol.style.margin = "0";
                  ol.style.padding = "0 0 0 12px";
                  items.forEach((it) => {
                    const li = document.createElement("li");
                    li.className = "item";
                    li.dataset.num = String(it.num);

                    const span = document.createElement("span");
                    span.className = "label";
                    span.textContent = `#${it.num} — Page ${it.page}`;

                    const del = document.createElement("button");
                    del.className = "del";
                    del.title = "Delete this redaction";
                    del.textContent = "Delete";

                    span.addEventListener("click", () => {
                      it.el.scrollIntoView({
                        behavior: "smooth",
                        block: "center",
                      });
                      selectRect(it.el);
                    });
                    del.addEventListener("click", (ev) => {
                      ev.stopPropagation();
                      const pageEl = it.el.closest(".page");
                      it.el.remove();
                      persistPageRects(pageEl);
                    });

                    li.appendChild(span);
                    li.appendChild(del);
                    ol.appendChild(li);
                  });
                  redactList.classList.remove("hint");
                  redactList.appendChild(ol);
                }
              }
            } catch (e) {
              console.error("renumber/list failed", e);
            }
          }

          // Export image-only PDF (white fill, no border)
          exportBtn.addEventListener("click", async () => {
            if (!pdfDoc) return alert("Please select a PDF first");
            progressBar.removeAttribute("aria-hidden");
            progressFill.style.width = "0%";
            const { jsPDF } = jspdfNS;
            let outDoc = null;
            for (let p = 1; p <= pdfDoc.numPages; p++) {
              const page = await pdfDoc.getPage(p);
              const exportScale = 2.5;
              const vp1 = page.getViewport({ scale: 1 });
              const vp = page.getViewport({ scale: exportScale });
              const cvs = document.createElement("canvas");
              cvs.width = Math.ceil(vp.width);
              cvs.height = Math.ceil(vp.height);
              const ctx = cvs.getContext("2d");
              await page.render({ canvasContext: ctx, viewport: vp }).promise;
              const list = redactions.get(p) || [];
              ctx.save();
              ctx.fillStyle = "#fff";
              list.forEach((r) => {
                ctx.fillRect(
                  r.x * cvs.width,
                  r.y * cvs.height,
                  r.w * cvs.width,
                  r.h * cvs.height
                );
              });
              ctx.restore();
              const img = cvs.toDataURL("image/jpeg", 0.92);
              const pageWidthPt = (vp1.width * 72) / 96;
              const pageHeightPt = (vp1.height * 72) / 96;
              if (!outDoc) {
                outDoc = new jsPDF({
                  unit: "pt",
                  format: [pageWidthPt, pageHeightPt],
                });
              } else {
                outDoc.addPage([pageWidthPt, pageHeightPt]);
                outDoc.setPage(outDoc.getNumberOfPages());
              }
              outDoc.addImage(img, "JPEG", 0, 0, pageWidthPt, pageHeightPt);
              progressFill.style.width =
                Math.round((p / pdfDoc.numPages) * 100) + "%";
            }
            const blob = outDoc.output("blob");
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            // Export file name as "REDACTED - " + original name
            const safeName = originalFileName
              ? `REDACTED - ${originalFileName}`.replace(/\\s+/g, " ").trim()
              : "REDACTED - Document.pdf";
            a.download = safeName;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            setTimeout(() => {
              progressBar.setAttribute("aria-hidden", "true");
            }, 800);
          });
        }
      })();
    </script>

    <!-- Offline note (if CDNs are blocked):
    1) Place pdfjs-dist/build/pdf.min.js & pdf.worker.min.js and jspdf/dist/jspdf.umd.min.js next to this HTML.
    2) Point the loader arrays to ['./pdf.min.js'] and ['./jspdf.umd.min.js'] respectively.
    3) Serve via a local HTTP server (e.g. `npx serve .`) instead of opening via file:// for best compatibility.
  --></body>
</html>
